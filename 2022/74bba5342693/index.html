<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Kubernetes实战 | Jeremy</title><meta name="author" content="Jeremyhzf"><meta name="copyright" content="Jeremyhzf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Kubernetes概述1、K8s介绍Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。"><meta property="og:type" content="article"><meta property="og:title" content="Kubernetes实战"><meta property="og:url" content="https://jeremyhzf.com/2022/74bba5342693/index.html"><meta property="og:site_name" content="Jeremy"><meta property="og:description" content="一、Kubernetes概述1、K8s介绍Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/Kuberbetes.png"><meta property="article:published_time" content="2022-10-06T03:43:29.000Z"><meta property="article:modified_time" content="2022-10-06T03:43:29.000Z"><meta property="article:author" content="Jeremyhzf"><meta property="article:tag" content="Kubernetes"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/Kuberbetes.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jeremyhzf.com/2022/74bba5342693/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Kubernetes实战",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-10-06 11:43:29"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Jeremy" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/Kuberbetes.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jeremy</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-06T03:43:29.000Z" title="发表于 2022-10-06 11:43:29">2022-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-06T03:43:29.000Z" title="更新于 2022-10-06 11:43:29">2022-10-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Kubernetes实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Kubernetes概述"><a href="#一、Kubernetes概述" class="headerlink" title="一、Kubernetes概述"></a>一、Kubernetes概述</h1><h3 id="1、K8s介绍"><a href="#1、K8s介绍" class="headerlink" title="1、K8s介绍"></a>1、K8s介绍</h3><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。</p><span id="more"></span><h3 id="2、K8s能做什么"><a href="#2、K8s能做什么" class="headerlink" title="2、K8s能做什么"></a>2、K8s能做什么</h3><p>Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p><blockquote><p>应用部署架构分类：</p><ol><li>无中心节点架构：GlusterFS</li><li>有中心节点架构：HDFS(Yarn) 和 K8S</li></ol></blockquote><p>Kubernetes 为你提供：</p><ul><li><p><strong>服务发现和负载均衡</strong></p><p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p><strong>自动部署和回滚</strong></p><p>你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p></li><li><p><strong>自动完成装箱计算</strong></p><p>你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。</p></li><li><p><strong>自我修复</strong></p><p>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong></p><p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><blockquote></blockquote><h3 id="3、K8s不能做什么"><a href="#3、K8s不能做什么" class="headerlink" title="3、K8s不能做什么"></a>3、K8s不能做什么</h3><p><strong>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统</strong>。 由于 Kubernetes 是在容器级别运行，而非在硬件级别，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。 但是，Kubernetes 不是单体式（monolithic）系统，那些默认解决方案都是可选、可插拔的。 Kubernetes 为构建开发人员平台提供了基础，但是在重要的地方保留了用户选择权，能有更高的灵活性。</p><p>Kubernetes：</p><ul><li><p><strong>不限制支持的应用程序类型</strong>。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</p></li><li><p><strong>不部署源代码，也不构建你的应用程序</strong>。 持续集成（CI）、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。</p></li><li><p><strong>不提供应用程序级别的服务作为内置服务</strong>，例如中间件（例如消息中间件）、 数据处理框架（例如 Spark）、数据库（例如 MySQL）、缓存、集群存储系统 （例如 Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制 （例如<a target="_blank" rel="noopener" href="https://openservicebrokerapi.org/">开放服务代理</a>）来访问。</p></li><li><p><strong>不是日志记录、监视或警报的解决方案</strong>。 它集成了一些功能作为概念证明，并提供了收集和导出指标的机制。</p></li><li><p><strong>不提供也不要求配置用的语言、系统</strong>（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。</p></li><li><p><strong>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统</strong>。</p></li><li><p>此外，<strong>Kubernetes 不仅仅是一个编排系统</strong>，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 而 Kubernetes 包含了一组独立可组合的控制过程，可以连续地将当前状态驱动到所提供的预期状态。 你不需要在乎如何从 A 移动到 C，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮，更为弹性和可扩展。</p></li></ul><h3 id="4、K8s集群节点主要组件和功能"><a href="#4、K8s集群节点主要组件和功能" class="headerlink" title="4、K8s集群节点主要组件和功能"></a>4、K8s集群节点主要组件和功能</h3><h4 id="4-1-控制平面组件（Control-Plane-Components）"><a href="#4-1-控制平面组件（Control-Plane-Components）" class="headerlink" title="4.1 控制平面组件（Control Plane Components）"></a>4.1 控制平面组件（Control Plane Components）</h4><p>控制平面组件也叫Master组件，对集群进行<strong>资源调度</strong>、以及<strong>检测</strong>和<strong>响应</strong>集群事件。</p><p>Master节点主要由<code>kube-apiserver</code>、<code>etcd</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>、<code>cloud-controller-manager</code>所组成。</p><h4 id="4-2-Node-组件"><a href="#4-2-Node-组件" class="headerlink" title="4.2 Node 组件"></a>4.2 Node 组件</h4><p>集群工作节点，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p><p>Node节点主要由<code>kubelet</code>、<code>kube-proxy</code>、容器运行时环境（Container Runtime）组成。</p><h1 id="二、K8s集群搭建"><a href="#二、K8s集群搭建" class="headerlink" title="二、K8s集群搭建"></a>二、K8s集群搭建</h1><blockquote><p>K8s常见安装方式有工具部署和二进制包部署，本教程以官方部署工具Kubeadm进行部署。</p><ol><li>工具部署：Kubeadm（官方工具）、Kops、Kubespray</li><li>二进制包部署：官方下载二进制包手动编译部署。</li></ol></blockquote><h3 id="1、搭建准备"><a href="#1、搭建准备" class="headerlink" title="1、搭建准备"></a>1、搭建准备</h3><ul><li>准备多台机器（操作系统Centos7）</li><li>配置好网络（可以翻墙，国内太慢）</li><li>禁止swap分区</li></ul><h3 id="2、系统初始化"><a href="#2、系统初始化" class="headerlink" title="2、系统初始化"></a>2、系统初始化</h3><h4 id="2-1-关闭防火墙"><a href="#2-1-关闭防火墙" class="headerlink" title="2.1 关闭防火墙"></a>2.1 关闭防火墙</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl stop firewalld</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">disable</span> firewalld</span></span><br></pre></td></tr></table></figure><h4 id="2-2-关闭selinux"><a href="#2-2-关闭selinux" class="headerlink" title="2.2 关闭selinux"></a>2.2 关闭selinux</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="comment"># 永久关闭</span></span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setenforce 0  <span class="comment"># 临时关闭</span></span></span><br></pre></td></tr></table></figure><h4 id="2-3-关闭swap"><a href="#2-3-关闭swap" class="headerlink" title="2.3 关闭swap"></a>2.3 关闭swap</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/fstab  <span class="comment"># 永久</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapoff -a  <span class="comment"># 临时</span></span></span><br></pre></td></tr></table></figure><h4 id="2-4-设置主机名"><a href="#2-4-设置主机名" class="headerlink" title="2.4 设置主机名"></a>2.4 设置主机名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostnamectl set-hostname &lt;hostname&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-添加hosts"><a href="#2-5-添加hosts" class="headerlink" title="2.5 添加hosts"></a>2.5 添加hosts</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">192.168.31.61 k8s-master</span><br><span class="line">192.168.31.62 k8s-node1</span><br><span class="line">192.168.31.63 k8s-node2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="2-6-将桥接的-IPv4-流量传递到-iptables-的链"><a href="#2-6-将桥接的-IPv4-流量传递到-iptables-的链" class="headerlink" title="2.6 将桥接的 IPv4 流量传递到 iptables 的链"></a>2.6 将桥接的 IPv4 流量传递到 iptables 的链</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span> </span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1 </span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sysctl --system # 生效</span></span></span><br></pre></td></tr></table></figure><h4 id="2-7-时间同步"><a href="#2-7-时间同步" class="headerlink" title="2.7 时间同步"></a>2.7 时间同步</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install ntpdate -y</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ntpdate time.windows.com</span></span><br></pre></td></tr></table></figure><h3 id="3、安装Docker、Kubeadm、Kubelet"><a href="#3、安装Docker、Kubeadm、Kubelet" class="headerlink" title="3、安装Docker、Kubeadm、Kubelet"></a>3、安装Docker、Kubeadm、Kubelet</h3><blockquote><p>所有机器都需要安装</p></blockquote><h4 id="3-1-安装Docker"><a href="#3-1-安装Docker" class="headerlink" title="3.1 安装Docker"></a>3.1 安装Docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 1: 卸载旧版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum remove docker  docker-client docker-client-latest docker-common docker-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-latest-logrotate docker-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-engine</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 2: 安装依赖包并设置仓库源</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install -y yum-utils \</span></span><br><span class="line"><span class="language-bash">  device-mapper-persistent-data \</span></span><br><span class="line"><span class="language-bash">  lvm2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum-config-manager --add-repo \</span></span><br><span class="line"><span class="language-bash">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo                <span class="comment"># 阿里云源</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum-config-manager --add-repo \</span></span><br><span class="line"><span class="language-bash">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo     <span class="comment"># 清华源</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 3：安装Docker CE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install -y docker-ce docker-ce-cli containerd.io</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 4: 设置开机自启</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 5: 验证是否安装成功</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker --version</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置阿里云Docker加速（可选）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF &#123;</span></span></span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;] &#125;         # 登陆自己的阿里云复制链接</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo systemctl daemon-reload</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo systemctl restart docker</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">配置阿里云yum源（可选）</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">sudo cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span></span> </span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 </span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="3-2-安装kubeadm，kubelet-和-kubectl"><a href="#3-2-安装kubeadm，kubelet-和-kubectl" class="headerlink" title="3.2 安装kubeadm，kubelet 和 kubectl"></a>3.2 安装kubeadm，kubelet 和 kubectl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y kubelet kubeadm kubectl</span>     </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> kubelet</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl start kubelet</span></span><br></pre></td></tr></table></figure><blockquote><p>Mac 部署K8s注意调大Docker Desktop资源，网速不好可以手动拉取K8s镜像，但需要注意版本。</p></blockquote><h3 id="4、部署K8s-Master"><a href="#4、部署K8s-Master" class="headerlink" title="4、部署K8s Master"></a>4、部署K8s Master</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 1：在Master节点安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果直接执行命令出错或者太慢，可以先手动把镜像拉下来在执行的命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init \</span></span><br><span class="line"><span class="language-bash">--apiserver-advertise-address=10.0.2.15 \                          <span class="comment"># 注意apiserver地址</span></span></span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \       # aliyun源</span><br><span class="line">--kubernetes-version v1.17.3 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \ </span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 2：启用kubectl</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 3：安装Pod网站插件（CNI）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply –f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">watch kubectl get pod -n kube-system -o wide   <span class="comment"># 监控pod进度</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 4：使用kubectl工具</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes                          <span class="comment"># 获取所有节点</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get namespaces                     <span class="comment"># 获取所有namespaces</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n &lt;namespaces&gt;           <span class="comment"># 获取所有Pod，可以添加 &lt;--all-namespaces&gt; 参数。</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动拉取镜像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">	kube-apiserver:v1.17.3</span><br><span class="line">    kube-proxy:v1.17.3</span><br><span class="line">	kube-controller-manager:v1.17.3</span><br><span class="line">	kube-scheduler:v1.17.3</span><br><span class="line">	coredns:1.6.5</span><br><span class="line">	etcd:3.4.3-0</span><br><span class="line">    pause:3.1</span><br><span class="line">)</span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span>  k8s.gcr.io/<span class="variable">$imageName</span></span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>如果直接执行Step 1 命令出错或者太慢，可以先手动把镜像拉下来在执行Step 1 的命令；</p><p>更多拓展插件：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/">https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/</a> ；</p><p>Step 3安装网络插件如果image拉不下来可以取Docker hub上找一个并修改kube-flannel.yml文件地址；</p></blockquote><h3 id="5、部署Node节点，并加入K8s集群"><a href="#5、部署Node节点，并加入K8s集群" class="headerlink" title="5、部署Node节点，并加入K8s集群"></a>5、部署Node节点，并加入K8s集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">部署Node节点，并将新节点添加到K8s集群，注意修改 IP地址</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm <span class="built_in">join</span> &lt;Master节点IP&gt;:6443 --token esce21.q6hetwm8si29qxwn \</span></span><br><span class="line"><span class="language-bash">--discovery-token-ca-cert-hash sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果token过期，手动生成token</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm token create --print-join-command</span></span><br></pre></td></tr></table></figure><h3 id="6、测试集群-部署一个应用"><a href="#6、测试集群-部署一个应用" class="headerlink" title="6、测试集群(部署一个应用)"></a>6、测试集群(部署一个应用)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 1：使用 kubectl 创建Deployment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 2：查看Pods和Nodes</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods &lt;namespaces&gt;</span>   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes -o wide      <span class="comment"># -o wide 打印详细信息</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 3：使用Service暴露应用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl expose deployment tomcat6 --port=80 --target-port=8080 --<span class="built_in">type</span>=NodePort</span>   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get service       <span class="comment"># 查看访问端口</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 4：应用伸缩</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale --replicas=3 deployment tomcat6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 5：应用更新</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployment.apps/&lt;deployment名称&gt; &lt;容器名称&gt;=&lt;镜像&gt;:&lt;版本&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployment.apps/tomcat7 tomcat7=tomcat:7.0.53-jre8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 6：回滚应用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="built_in">history</span> deployment tomcat7                       <span class="comment"># 查看deployment记录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="built_in">history</span> deployment tomcat7 --revision=&lt;版本号&gt;    <span class="comment"># 查看版本详细信息</span></span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment tomcat7 --to-revision=&lt;版本号&gt;    <span class="comment"># 回退到某个版本</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 7：其他命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment tomcat6 --image=tomcat:6.0.53-jre8 --dry-run -o yaml    <span class="comment"># 预执行并打印yaml</span></span></span><br></pre></td></tr></table></figure><h3 id="7、常用命令"><a href="#7、常用命令" class="headerlink" title="7、常用命令"></a>7、常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get node -o wide                           <span class="comment"># 获取集群节点</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ns                                     <span class="comment"># 获取namespaces</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get all --all-namespaces</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods --all-namespaces                  <span class="comment"># 获取pod</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod -n kube-system</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get svc -n kube-system                     <span class="comment"># 获取services</span></span></span><br></pre></td></tr></table></figure><p>到此K8s集群已经搭建完成。</p><h1 id="TUDO"><a href="#TUDO" class="headerlink" title="TUDO"></a>TUDO</h1><p>部署可视化界面、部署helm、部署KubeSphere</p><h1 id="三、核心架构"><a href="#三、核心架构" class="headerlink" title="三、核心架构"></a>三、核心架构</h1><blockquote><p>K8s 中文文档： <a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/251.html">http://docs.kubernetes.org.cn/251.html</a></p></blockquote><h2 id="1、K8s架构"><a href="#1、K8s架构" class="headerlink" title="1、K8s架构"></a>1、K8s架构</h2><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源:</p><ul><li><strong>Master</strong> 调度整个集群</li><li><strong>Nodes</strong> 负责运行应用</li></ul><p><img src="../Img/architecture.png" alt="architecture"></p><p>Kubernetes主要由以下几个核心组件组成：</p><ul><li>etcd保存了整个集群的状态；</li><li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li><li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li><li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li></ul><p>除了核心组件，还有一些推荐的Add-ons：</p><ul><li>kube-dns负责为整个集群提供DNS服务</li><li>Ingress Controller为服务提供外网入口</li><li>Heapster提供资源监控</li><li>Dashboard提供GUI</li><li>Federation提供跨可用区的集群</li><li>Fluentd-elasticsearch提供集群日志采集、存储与查询</li></ul><p><img src="../Img/14791969222306.png" alt="img"></p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/14791969311297.png" alt="img"></p><p><strong>分层架构</strong></p><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示</p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/14937095836427.jpg" alt="img"></p><ul><li>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/148.html">RBAC</a>、Quota、PSP、NetworkPolicy等）</li><li>接口层：<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/61.html">kubectl命令行工具</a>、客户端SDK以及集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<ul><li>Kubernetes外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等</li><li>Kubernetes内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li></ul></li></ul><h2 id="2、部署一个应用"><a href="#2、部署一个应用" class="headerlink" title="2、部署一个应用"></a>2、部署一个应用</h2><p>在K8s中部署一个应用的整个过程</p><blockquote><p>官方文档教学： <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/">https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/</a></p></blockquote><h3 id="1、使用-kubectl-创建Deployment"><a href="#1、使用-kubectl-创建Deployment" class="headerlink" title="1、使用 kubectl 创建Deployment"></a>1、使用 kubectl 创建Deployment</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Deployment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment &lt;deployment名称&gt; --image=&lt;镜像名称&gt;:&lt;镜像版本&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Deployment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment</span></span><br></pre></td></tr></table></figure><h4 id="Kubernetes-Deployments"><a href="#Kubernetes-Deployments" class="headerlink" title="Kubernetes Deployments"></a>Kubernetes Deployments</h4><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，你需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><p>在没有 Kubernetes 这种编排系统之前，安装脚本通常用于启动应用程序，但它们不允许从机器故障中恢复。通过创建应用程序实例并使它们在节点之间运行， Kubernetes Deployments 提供了一种与众不同的应用程序管理方法。</p><h4 id="在Kubernetes上部署第一个应用程序"><a href="#在Kubernetes上部署第一个应用程序" class="headerlink" title="在Kubernetes上部署第一个应用程序"></a>在Kubernetes上部署第一个应用程序</h4><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_02_first_app.svg" alt="img"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p><em>Master 管理集群，Node 用于托管正在运行的应用。</em></p><p>在 Kubernetes 上部署应用时，你告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h3 id="2、Pod和Node"><a href="#2、Pod和Node" class="headerlink" title="2、Pod和Node"></a>2、Pod和Node</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f pod.yaml</span></span><br></pre></td></tr></table></figure><h4 id="Kubernetes-Pods"><a href="#Kubernetes-Pods" class="headerlink" title="Kubernetes Pods"></a>Kubernetes Pods</h4><p>在创建 Deployment 时, Kubernetes 添加了一个 <strong>Pod</strong> 来托管你的应用实例。Pod 是 Kubernetes 抽象出来的，表示一组一个或多个应用程序容器（如 Docker），以及这些容器的一些共享资源。这些资源包括:</p><ul><li>共享存储，当作卷</li><li>网络，作为唯一的集群 IP 地址</li><li>有关每个容器如何运行的信息，例如容器镜像版本或要使用的特定端口。</li></ul><p>Pod 为特定于应用程序的“逻辑主机”建模，并且可以包含相对紧耦合的不同应用容器。例如，Pod 可能既包含带有 Node.js 应用的容器，也包含另一个不同的容器，用于提供 Node.js 网络服务器要发布的数据。Pod 中的容器共享 IP 地址和端口，始终位于同一位置并且共同调度，并在同一工作节点上的共享上下文中运行。</p><p>Pod是 Kubernetes 平台上的原子单元。 当我们在 Kubernetes 上创建 Deployment 时，该 Deployment 会在其中创建包含容器的 Pod （而不是直接创建容器）。每个 Pod 都与调度它的工作节点绑定，并保持在那里直到终止（根据重启策略）或删除。 如果工作节点发生故障，则会在集群中的其他可用工作节点上调度相同的 Pod。</p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_03_pods.svg" alt="img"></p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>一个Pod总是在一个<strong>Node节点</strong>上运行，Node是Kubernetes中的工作节点，可以是虚拟机或物理机。每个Node由 Master管理，Node上可以有多个pod，Kubernetes Master会自动处理群集中Node的pod调度，同时Master的自动调度会考虑每个Node上的可用资源。</p><p>每个Kubernetes Node上至少运行着：</p><ul><li>Kubelet，管理Kubernetes Master和Node之间的通信; 管理机器上运行的Pods和containers容器。</li><li>container runtime（如Docker，rkt）。</li></ul><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_03_nodes.svg" alt="img"></p><h4 id="使用-kubectl-进行故障排除"><a href="#使用-kubectl-进行故障排除" class="headerlink" title="使用 kubectl 进行故障排除"></a>使用 kubectl 进行故障排除</h4><p>使用了Kubectl 命令管理工具。我们继续在模块3中使用它来获取有关Deployment的应用及其环境信息。常见的操作可以通过以下kubectl命令完成：</p><ul><li><strong>kubectl get -</strong> 列出资源</li><li><strong>kubectl describe</strong> - 显示资源的详细信息</li><li><strong>kubectl logs</strong> - 打印pod中的容器日志</li><li><strong>kubectl exec</strong> - pod中容器内部执行命令</li></ul><p>可以使用这些命令来查看应用程序何时部署、它们当前的状态是什么、它们在哪里运行以及它们的配置是什么。</p><h3 id="3、Service"><a href="#3、Service" class="headerlink" title="3、Service"></a>3、Service</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f service.yaml</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get service</span></span><br></pre></td></tr></table></figure><p>Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 是转瞬即逝的。 Pod 实际上拥有 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/">生命周期</a>。 当一个工作 Node 挂掉后, 在 Node 上运行的 Pod 也会消亡。 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 会自动地通过创建新的 Pod 驱动集群回到目标状态，以保证应用程序正常运行。 换一个例子，考虑一个具有3个副本数的用作图像处理的后端程序。这些副本是可替换的; 前端系统不应该关心后端副本，即使 Pod 丢失或重新创建。也就是说，Kubernetes 集群中的每个 Pod (即使是在同一个 Node 上的 Pod )都有一个唯一的 IP 地址，因此需要一种方法自动协调 Pod 之间的变更，以便应用程序保持运行。</p><p>Kubernetes 中的服务(Service)是一种抽象概念，它定义了 Pod 的逻辑集和访问 Pod 的协议。Service 使从属 Pod 之间的松耦合成为可能。 和其他 Kubernetes 对象一样, Service 用 YAML <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/configuration/overview/#general-configuration-tips">(更推荐)</a> 或者 JSON 来定义. Service 下的一组 Pod 通常由 <em>LabelSelector</em> (请参阅下面的说明为什么你可能想要一个 spec 中不包含<code>selector</code>的服务)来标记。</p><p>尽管每个 Pod 都有一个唯一的 IP 地址，但是如果没有 Service ，这些 IP 不会暴露在集群外部。Service 允许你的应用程序接收流量。Service 也可以用在 ServiceSpec 标记<code>type</code>的方式暴露</p><ul><li><em>ClusterIP</em> (默认) - 在集群的内部 IP 上公开 Service 。这种类型使得 Service 只能从集群内访问。</li><li><em>NodePort</em> - 使用 NAT 在集群中每个选定 Node 的相同端口上公开 Service 。使用<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 从集群外部访问 Service。是 ClusterIP 的超集。</li><li><em>LoadBalancer</em> - 在当前云中创建一个外部负载均衡器(如果支持的话)，并为 Service 分配一个固定的外部IP。是 NodePort 的超集。</li><li><em>ExternalName</em> - 通过返回带有该名称的 CNAME 记录，使用任意名称(由 spec 中的<code>externalName</code>指定)公开 Service。不使用代理。这种类型需要<code>kube-dns</code>的v1.7或更高版本。</li></ul><p>更多关于不同 Service 类型的信息可以在<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tutorials/services/source-ip/">使用源 IP</a> 教程。 也请参阅 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/connect-applications-service">连接应用程序和 Service </a>。</p><p>另外，需要注意的是有一些 Service 的用例没有在 spec 中定义<code>selector</code>。 一个没有<code>selector</code>创建的 Service 也不会创建相应的端点对象。这允许用户手动将服务映射到特定的端点。没有 selector 的另一种可能是你严格使用<code>type: ExternalName</code>来标记。</p><blockquote><p><em>Kubernetes 的 Service 是一个抽象层，它定义了一组 Pod 的逻辑集，并为这些 Pod 支持外部流量暴露、负载平衡和服务发现。</em></p></blockquote><h4 id="Services和Labels"><a href="#Services和Labels" class="headerlink" title="Services和Labels"></a>Services和Labels</h4><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_04_services.svg" alt="img"></p><p>如上图，A中Service 路由一组Pods的流量。Service允许pod在Kubernetes中被销毁并复制pod而不影响应用。相关Pod之间的发现和路由（如应用中的前端和后端组件）由Kubernetes Services处理。</p><p>Service 使用<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/247.html">label selectors</a>来匹配一组Pod，允许对Kubernetes中的对象进行逻辑运算，Label以key/value 键/值对附加到对象上。以多种方式使用：</p><ul><li>指定用于开发，测试和生产的对象</li><li>嵌入版本Label</li><li>使用Label分类对象</li></ul><blockquote><p><em>你可以在使用<code>--expose</code>kubectl 创建 Deployment 的同时创建 Service 。</em></p></blockquote><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_04_labels-20220921215509387.svg" alt="img"></p><p>标签(Label)可以在创建时或之后附加到对象上。他们可以随时被修改。现在使用 Service 发布我们的应用程序并添加一些 Label 。</p><h3 id="4、扩缩应用程序"><a href="#4、扩缩应用程序" class="headerlink" title="4、扩缩应用程序"></a>4、扩缩应用程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployment.apps/&lt;deployment名称&gt; &lt;容器名称&gt;=&lt;镜像&gt;:&lt;版本&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployment.apps/tomcat7 tomcat6=tomcat:6.0.53-jre8</span></span><br></pre></td></tr></table></figure><p>在之前的模块中，我们创建了一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>，然后通过 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">Service</a>让其可以开放访问。Deployment 仅为跑这个应用程序创建了一个 Pod。 当流量增加时，我们需要扩容应用程序满足用户需求。</p><p><strong>扩缩</strong> 是通过改变 Deployment 中的副本数量来实现的。</p><blockquote><p><em>在运行 kubectl run 命令时，你可以通过设置 –replicas 参数来设置 Deployment 的副本数。</em></p></blockquote><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_05_scaling1.svg" alt="img"></p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_05_scaling2.svg" alt="img"></p><p>扩展 Deployment 将创建新的 Pods，并将资源调度请求分配到有可用资源的节点上，收缩 会将 Pods 数量减少至所需的状态。Kubernetes 还支持 Pods 的<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/">自动缩放</a>，但这并不在本教程的讨论范围内。将 Pods 数量收缩到0也是可以的，但这会终止 Deployment 上所有已经部署的 Pods。</p><p>运行应用程序的多个实例需要在它们之间分配流量。服务 (Service)有一种负载均衡器类型，可以将网络流量均衡分配到外部可访问的 Pods 上。服务将会一直通过端点来监视 Pods 的运行，保证流量只分配到可用的 Pods 上。</p><p>一旦有了多个应用实例，就可以没有宕机地滚动更新。</p><blockquote><p><em>扩缩是通过改变 Deployment 中的副本数量来实现的。</em></p></blockquote><h3 id="5、更新应用程序"><a href="#5、更新应用程序" class="headerlink" title="5、更新应用程序"></a>5、更新应用程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="built_in">history</span> deployment tomcat7                       <span class="comment"># 查看deployment记录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="built_in">history</span> deployment tomcat7 --revision=&lt;版本号&gt;    <span class="comment"># 查看版本详细信息</span></span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment tomcat7 --to-revision=&lt;版本号&gt;    <span class="comment"># 回退到某个版本</span></span></span><br></pre></td></tr></table></figure><p>用户希望应用程序始终可用，而开发人员则需要每天多次部署它们的新版本（一个简单例子，大家在玩游戏时常常碰到这类公告：8月8日凌晨：2点-6点服务升级，暂停所有服务…..）*。在 Kubernetes 中，这些是通过<strong>滚动更新</strong>（Rolling Updates）完成的。 <strong>滚动更新</strong> 允许通过使用新的实例逐步更新 Pod 实例，零停机进行 Deployment 更新。新的 Pod 将在具有可用资源的节点上进行调度。</p><p>在前面的模块中，我们将应用程序扩展为运行多个实例。这是在不影响应用程序可用性的情况下执行更新的要求。默认情况下，更新期间不可用的 pod 的最大值和可以创建的新 pod 数都是 1。这两个选项都可以配置为（pod）数字或百分比。 在 Kubernetes 中，更新是经过版本控制的，任何 Deployment 更新都可以恢复到以前的（稳定）版本，支持升级 / 回滚（恢复）更新。</p><blockquote><p><em>滚动更新允许通过使用新的实例逐步更新 Pod 实例从而实现 Deployments 更新，停机时间为零。</em></p></blockquote><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_06_rollingupdates1.svg" alt="img"></p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_06_rollingupdates2.svg" alt="img"></p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_06_rollingupdates3.svg" alt="img"></p><p><img src="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/module_06_rollingupdates4.svg" alt="img"></p><p>与应用程序扩展类似，如果 Deployment 是公开的，服务将在更新期间仅对可用的 pod 进行负载均衡。可用 Pod 是应用程序用户可用的实例。</p><p>滚动更新允许以下操作：</p><ul><li>将应用程序从一个环境提升到另一个环境（通过容器镜像更新）</li><li>回滚到以前的版本</li><li>持续集成和持续交付应用程序，无需停机</li></ul><blockquote><p><em>如果 Deployment 是公开的，则服务将仅在更新期间对可用的 pod 进行负载均衡。</em></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>K8s官方文档：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/home/">https://kubernetes.io/zh-cn/docs/home/</a></p></li><li><p>K8s中文社区文档：<a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/">http://docs.kubernetes.org.cn/</a></p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jeremyhzf.com">Jeremyhzf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jeremyhzf.com/2022/74bba5342693/">https://jeremyhzf.com/2022/74bba5342693/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jeremyhzf.com" target="_blank">Jeremy</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kubernetes/">Kubernetes</a></div><div class="post_share"><div class="social-share" data-image="https://jeremyhzf-blog.oss-cn-hongkong.aliyuncs.com/Kuberbetes.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/3b0bbb655961/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo+NexT搭建静态博客</div></div></a></div><div class="next-post pull-right"><a href="/2021/20a4c81881b2/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式一致性</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Kubernetes%E6%A6%82%E8%BF%B0"><span class="toc-text">一、Kubernetes概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81K8s%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、K8s介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81K8s%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">2、K8s能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81K8s%E4%B8%8D%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">3、K8s不能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81K8s%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-text">4、K8s集群节点主要组件和功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%88Control-Plane-Components%EF%BC%89"><span class="toc-text">4.1 控制平面组件（Control Plane Components）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Node-%E7%BB%84%E4%BB%B6"><span class="toc-text">4.2 Node 组件</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81K8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-text">二、K8s集群搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%90%AD%E5%BB%BA%E5%87%86%E5%A4%87"><span class="toc-text">1、搭建准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2、系统初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-text">2.1 关闭防火墙</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%85%B3%E9%97%ADselinux"><span class="toc-text">2.2 关闭selinux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%85%B3%E9%97%ADswap"><span class="toc-text">2.3 关闭swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-text">2.4 设置主机名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%B7%BB%E5%8A%A0hosts"><span class="toc-text">2.5 添加hosts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%B0%86%E6%A1%A5%E6%8E%A5%E7%9A%84-IPv4-%E6%B5%81%E9%87%8F%E4%BC%A0%E9%80%92%E5%88%B0-iptables-%E7%9A%84%E9%93%BE"><span class="toc-text">2.6 将桥接的 IPv4 流量传递到 iptables 的链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="toc-text">2.7 时间同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85Docker%E3%80%81Kubeadm%E3%80%81Kubelet"><span class="toc-text">3、安装Docker、Kubeadm、Kubelet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AE%89%E8%A3%85Docker"><span class="toc-text">3.1 安装Docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AE%89%E8%A3%85kubeadm%EF%BC%8Ckubelet-%E5%92%8C-kubectl"><span class="toc-text">3.2 安装kubeadm，kubelet 和 kubectl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%83%A8%E7%BD%B2K8s-Master"><span class="toc-text">4、部署K8s Master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%83%A8%E7%BD%B2Node%E8%8A%82%E7%82%B9%EF%BC%8C%E5%B9%B6%E5%8A%A0%E5%85%A5K8s%E9%9B%86%E7%BE%A4"><span class="toc-text">5、部署Node节点，并加入K8s集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4-%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8"><span class="toc-text">6、测试集群(部署一个应用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">7、常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TUDO"><span class="toc-text">TUDO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="toc-text">三、核心架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81K8s%E6%9E%B6%E6%9E%84"><span class="toc-text">1、K8s架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8"><span class="toc-text">2、部署一个应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8-kubectl-%E5%88%9B%E5%BB%BADeployment"><span class="toc-text">1、使用 kubectl 创建Deployment</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-Deployments"><span class="toc-text">Kubernetes Deployments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Kubernetes%E4%B8%8A%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">在Kubernetes上部署第一个应用程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Pod%E5%92%8CNode"><span class="toc-text">2、Pod和Node</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-Pods"><span class="toc-text">Kubernetes Pods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node"><span class="toc-text">Node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-kubectl-%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-text">使用 kubectl 进行故障排除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Service"><span class="toc-text">3、Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Services%E5%92%8CLabels"><span class="toc-text">Services和Labels</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%89%A9%E7%BC%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">4、扩缩应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">5、更新应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jeremyhzf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>